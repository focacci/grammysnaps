#!/bin/bash

# Production/Staging Deployment Script
# Usage: ./scripts/deploy -e <environment> -b <branch>

set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to display usage
usage() {
    echo "Usage: $0 -e <environment> -b <branch>"
    echo ""
    echo "Required arguments:"
    echo "  -e, --environment    staging (us-east-2) or production (us-east-1)"
    echo "  -b, --branch        branch to checkout before deploying"
    echo ""
    echo "Examples:"
    echo "  $0 -e staging -b main"
    echo "  $0 -e production -b RELEASE-v1.2.0"
    echo ""
    echo "Notes:"
    echo "  - Production releases require branch name starting with 'RELEASE-'"
    echo "  - Deployment will fail if there are unstaged changes"
    exit 1
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        -e|--environment)
            ENVIRONMENT="$2"
            shift 2
            ;;
        -b|--branch)
            BRANCH="$2"
            shift 2
            ;;
        -h|--help)
            usage
            ;;
        *)
            echo -e "${RED}Error: Unknown argument $1${NC}"
            usage
            ;;
    esac
done

# Validate required arguments
if [[ -z "$ENVIRONMENT" || -z "$BRANCH" ]]; then
    echo -e "${RED}Error: Both environment and branch are required${NC}"
    usage
fi

# Validate environment
if [[ "$ENVIRONMENT" != "staging" && "$ENVIRONMENT" != "production" ]]; then
    echo -e "${RED}Error: Environment must be 'staging' or 'production'${NC}"
    usage
fi

# Validate production branch naming
if [[ "$ENVIRONMENT" == "production" && ! "$BRANCH" =~ ^RELEASE- ]]; then
    echo -e "${RED}Error: Production deployments require a branch starting with 'RELEASE-'${NC}"
    echo -e "${YELLOW}Example: RELEASE-v1.2.0${NC}"
    exit 1
fi

# Set environment-specific variables
if [[ "$ENVIRONMENT" == "production" ]]; then
    AWS_REGION="us-east-1"
    ECR_REGISTRY="124314579010.dkr.ecr.us-east-1.amazonaws.com"
    CLUSTER_NAME="grammysnaps-prod-cluster"
    SERVICE_PREFIX="grammysnaps-prod"
    DOMAIN="grammysnaps.com"
else
    AWS_REGION="us-east-2"
    ECR_REGISTRY="124314579010.dkr.ecr.us-east-2.amazonaws.com"
    CLUSTER_NAME="grammysnaps-cluster"
    SERVICE_PREFIX="grammysnaps"
    DOMAIN="grammysnaps-alb-286162438.us-east-2.elb.amazonaws.com"
fi

PROJECT_NAME="grammysnaps"

echo -e "${BLUE}üöÄ Starting $ENVIRONMENT deployment from branch: $BRANCH${NC}"
echo -e "${BLUE}üìç Region: $AWS_REGION${NC}"
echo -e "${BLUE}üéØ Cluster: $CLUSTER_NAME${NC}"
echo ""

# Check for unstaged changes
echo -e "${YELLOW}üîç Checking for unstaged changes...${NC}"
if [[ -n $(git status --porcelain) ]]; then
    echo -e "${RED}‚ùå Deployment failed: You have unstaged changes${NC}"
    echo -e "${YELLOW}Please commit or stash your changes before deploying:${NC}"
    echo ""
    echo -e "${BLUE}Git Status:${NC}"
    git status
    echo ""
    echo -e "${YELLOW}To fix this, run one of:${NC}"
    echo -e "${CYAN}  git add . && git commit -m \"Your commit message\"${NC}"
    echo -e "${CYAN}  git stash${NC}"
    echo ""
    exit 1
fi
echo -e "${GREEN}‚úÖ No unstaged changes${NC}"

# Fetch latest changes and checkout branch
echo -e "${YELLOW}üì° Fetching latest changes...${NC}"
git fetch origin

echo -e "${YELLOW}üîÑ Checking out branch: $BRANCH${NC}"
if ! git checkout "$BRANCH"; then
    echo -e "${RED}‚ùå Error: Failed to checkout branch $BRANCH${NC}"
    exit 1
fi

# Pull latest changes for the branch
echo -e "${YELLOW}‚¨áÔ∏è Pulling latest changes for $BRANCH...${NC}"
git pull origin "$BRANCH"

# Get commit hash for tagging
COMMIT_HASH=$(git rev-parse --short HEAD)
echo -e "${BLUE}üìù Deploying commit: $COMMIT_HASH${NC}"

# Check for required dependencies
echo -e "${YELLOW}üîç Checking required dependencies...${NC}"
if ! command -v jq &> /dev/null; then
    echo -e "${RED}‚ùå Error: jq is required but not installed${NC}"
    echo -e "${YELLOW}Please install jq:${NC}"
    echo -e "${BLUE}   Ubuntu/Debian: sudo apt-get install jq${NC}"
    echo -e "${BLUE}   macOS: brew install jq${NC}"
    echo -e "${BLUE}   Amazon Linux: sudo yum install jq${NC}"
    exit 1
fi

if ! command -v aws &> /dev/null; then
    echo -e "${RED}‚ùå Error: AWS CLI is required but not installed${NC}"
    exit 1
fi

if ! command -v docker &> /dev/null; then
    echo -e "${RED}‚ùå Error: Docker is required but not installed${NC}"
    exit 1
fi

echo -e "${GREEN}‚úÖ All required dependencies are available${NC}"

# Check AWS credentials
echo -e "${YELLOW}‚òÅÔ∏è Verifying AWS credentials...${NC}"
if ! aws sts get-caller-identity --region "$AWS_REGION" >/dev/null; then
    echo -e "${RED}‚ùå Error: AWS credentials not configured or invalid${NC}"
    exit 1
fi
echo -e "${GREEN}‚úÖ AWS credentials verified${NC}"

# Login to ECR
echo -e "${YELLOW}üîê Logging into ECR...${NC}"

# Configure Docker to not use credential store to avoid pass initialization issues
mkdir -p ~/.docker
echo '{"credsStore": ""}' > ~/.docker/config.json

aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "$ECR_REGISTRY"

# Build and push API image
echo -e "${YELLOW}üê≥ Building API Docker image...${NC}"
cd api
docker build -t "$ECR_REGISTRY/$SERVICE_PREFIX-api:$COMMIT_HASH" .
docker tag "$ECR_REGISTRY/$SERVICE_PREFIX-api:$COMMIT_HASH" "$ECR_REGISTRY/$SERVICE_PREFIX-api:latest"

echo -e "${YELLOW}üì§ Pushing API image to ECR...${NC}"
docker push "$ECR_REGISTRY/$SERVICE_PREFIX-api:$COMMIT_HASH"
docker push "$ECR_REGISTRY/$SERVICE_PREFIX-api:latest"
cd ..

# Build and push Web image
echo -e "${YELLOW}üåê Building Web Docker image...${NC}"
cd web

# Set build arguments based on environment
if [[ "$ENVIRONMENT" == "staging" ]]; then
    API_URL="http://$DOMAIN"
    NODE_ENV="staging"
else
    API_URL="https://$DOMAIN"
    NODE_ENV="production"
fi

echo -e "${BLUE}üîß Building with environment variables:${NC}"
echo -e "${BLUE}   VITE_API_URL=$API_URL${NC}"
echo -e "${BLUE}   VITE_NODE_ENV=$NODE_ENV${NC}"

docker build \
    --build-arg VITE_API_URL="$API_URL" \
    --build-arg VITE_NODE_ENV="$NODE_ENV" \
    -t "$ECR_REGISTRY/$SERVICE_PREFIX-web:$COMMIT_HASH" .
docker tag "$ECR_REGISTRY/$SERVICE_PREFIX-web:$COMMIT_HASH" "$ECR_REGISTRY/$SERVICE_PREFIX-web:latest"

echo -e "${YELLOW}üì§ Pushing Web image to ECR...${NC}"
docker push "$ECR_REGISTRY/$SERVICE_PREFIX-web:$COMMIT_HASH"
docker push "$ECR_REGISTRY/$SERVICE_PREFIX-web:latest"
cd ..

# Function to update task definition and deploy service
update_task_definition_and_deploy() {
    local service_name=$1
    local image_uri=$2
    local container_name=$3
    
    echo -e "${YELLOW}ÔøΩ Updating task definition for $service_name...${NC}"
    
    # Get current task definition
    CURRENT_TASK_DEF=$(aws ecs describe-services \
        --cluster "$CLUSTER_NAME" \
        --services "$service_name" \
        --region "$AWS_REGION" \
        --query 'services[0].taskDefinition' \
        --output text)
    
    if [[ "$CURRENT_TASK_DEF" == "None" || -z "$CURRENT_TASK_DEF" ]]; then
        echo -e "${RED}‚ùå Error: Could not find current task definition for $service_name${NC}"
        return 1
    fi
    
    echo -e "${BLUE}   Current task definition: $CURRENT_TASK_DEF${NC}"
    
    # Get the task definition details
    TASK_DEF_JSON=$(aws ecs describe-task-definition \
        --task-definition "$CURRENT_TASK_DEF" \
        --region "$AWS_REGION" \
        --query 'taskDefinition')
    
    # Create temporary file for task definition processing
    TEMP_TASK_DEF=$(mktemp)
    echo "$TASK_DEF_JSON" > "$TEMP_TASK_DEF"
    
    # Validate JSON
    if ! jq empty "$TEMP_TASK_DEF" 2>/dev/null; then
        echo -e "${RED}‚ùå Error: Invalid JSON received from task definition${NC}"
        rm -f "$TEMP_TASK_DEF"
        return 1
    fi
    
    # Update the image URI in the task definition and create new temp file
    NEW_TASK_DEF_FILE=$(mktemp)
    jq --arg image_uri "$image_uri" --arg container_name "$container_name" '
        .containerDefinitions |= map(
            if .name == $container_name then
                .image = $image_uri
            else
                .
            end
        ) |
        del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .placementConstraints, .compatibilities, .registeredAt, .registeredBy)
    ' "$TEMP_TASK_DEF" > "$NEW_TASK_DEF_FILE"
    
    # Validate the new JSON
    if ! jq empty "$NEW_TASK_DEF_FILE" 2>/dev/null; then
        echo -e "${RED}‚ùå Error: Failed to create valid task definition JSON${NC}"
        rm -f "$TEMP_TASK_DEF" "$NEW_TASK_DEF_FILE"
        return 1
    fi
    
    # Register new task definition
    echo -e "${YELLOW}üìù Registering new task definition...${NC}"
    NEW_TASK_DEF_ARN=$(aws ecs register-task-definition \
        --region "$AWS_REGION" \
        --cli-input-json file://"$NEW_TASK_DEF_FILE" \
        --query 'taskDefinition.taskDefinitionArn' \
        --output text)
    
    # Clean up temp files
    rm -f "$TEMP_TASK_DEF" "$NEW_TASK_DEF_FILE"
    
    if [[ -z "$NEW_TASK_DEF_ARN" || "$NEW_TASK_DEF_ARN" == "None" ]]; then
        echo -e "${RED}‚ùå Error: Failed to register new task definition${NC}"
        return 1
    fi
    
    echo -e "${GREEN}‚úÖ New task definition registered: $NEW_TASK_DEF_ARN${NC}"
    
    # Update service to use new task definition
    echo -e "${YELLOW}üîÑ Updating $service_name service...${NC}"
    aws ecs update-service \
        --cluster "$CLUSTER_NAME" \
        --service "$service_name" \
        --task-definition "$NEW_TASK_DEF_ARN" \
        --region "$AWS_REGION" \
        --no-cli-pager > /dev/null
    
    echo -e "${GREEN}‚úÖ Service $service_name updated successfully${NC}"
}

# Update API service
echo -e "${YELLOW}üîÑ Deploying API service...${NC}"
update_task_definition_and_deploy \
    "$SERVICE_PREFIX-api" \
    "$ECR_REGISTRY/$SERVICE_PREFIX-api:$COMMIT_HASH" \
    "api"

# Update Web service  
echo -e "${YELLOW}üîÑ Deploying Web service...${NC}"
update_task_definition_and_deploy \
    "$SERVICE_PREFIX-web" \
    "$ECR_REGISTRY/$SERVICE_PREFIX-web:$COMMIT_HASH" \
    "web"

echo ""
echo -e "${GREEN}üéâ Deployment completed successfully!${NC}"
echo -e "${BLUE}üìä Environment: $ENVIRONMENT${NC}"
echo -e "${BLUE}üåç Region: $AWS_REGION${NC}"
echo -e "${BLUE}üìù Commit: $COMMIT_HASH${NC}"
echo -e "${BLUE}üåê URL: https://$DOMAIN${NC}"
echo ""
echo -e "${YELLOW}üìà Monitor deployment progress with:${NC}"
echo -e "${BLUE}   ./scripts/deployment-status $ENVIRONMENT${NC}"
echo ""
echo -e "${YELLOW}üîÑ To rollback if needed:${NC}"
echo -e "${BLUE}   aws ecs update-service --cluster $CLUSTER_NAME --service $SERVICE_PREFIX-api --task-definition <previous-task-def-arn> --region $AWS_REGION${NC}"
echo -e "${BLUE}   aws ecs update-service --cluster $CLUSTER_NAME --service $SERVICE_PREFIX-web --task-definition <previous-task-def-arn> --region $AWS_REGION${NC}"
echo ""
